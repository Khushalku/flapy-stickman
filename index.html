<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Doodle Dash: Auto-Morph</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@700&family=Permanent+Marker&family=Special+Elite&display=swap');

        body { 
            margin: 0; background: #111; 
            display: flex; justify-content: center; align-items: center; 
            height: 100vh; overflow: hidden; touch-action: none; 
        }

        #game-container { position: relative; }

        canvas { 
            display: block; max-width: 100%; max-height: 100%; 
            border: 5px solid #000; background: #fff;
            transition: background 0.5s ease, border-color 0.5s ease;
        }

        #ui { 
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            text-align: center; background: rgba(255,255,255,0.95); 
            padding: 30px; border: 4px solid #000; z-index: 10; width: 260px;
        }

        button { 
            background: #ffcc33; border: 3px solid #000; padding: 12px; 
            font-size: 18px; font-weight: bold; cursor: pointer; width: 100%; 
        }

        #styleToggle {
            position: absolute; top: 15px; right: 15px; width: 50px; height: 50px; 
            border-radius: 50%; z-index: 20; background: #fff; border: 3px solid #000; 
            font-weight: bold; box-shadow: 4px 4px 0px #000; display: flex;
            justify-content: center; align-items: center; font-size: 20px; padding: 0;
            transition: all 0.3s ease;
        }

        .font-classic { font-family: sans-serif; }
        .font-sketch { font-family: 'Permanent Marker', cursive; }
        .font-neon { font-family: 'Orbitron', sans-serif; }
        .font-blueprint { font-family: 'Special Elite', serif; }
    </style>
</head>
<body>

    <div id="game-container">
        <button id="styleToggle" title="Manual Switch">S</button>
        
        <div id="ui">
            <h1 id="title">DOODLE DASH</h1>
            <p id="msg">Styles change automatically!</p>
            <button id="startBtn">START</button>
        </div>

        <canvas id="game"></canvas>
    </div>
    
    <script>
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        const ui = document.getElementById('ui');
        const startBtn = document.getElementById('startBtn');
        const styleToggle = document.getElementById('styleToggle');

        // --- AUDIO ---
        const startSnd = new Audio('start.mp3');
        const gameOverSnd = new Audio('gameover.mp3');
        const milestoneSnd = new Audio('milestone.mp3');
        const warningSnd = new Audio('pass.mp3'); 

        const jumpPool = Array.from({length: 10}, () => new Audio('jump.mp3'));
        let poolIndex = 0;
        function playJump() {
            const s = jumpPool[poolIndex];
            s.pause(); s.currentTime = 0;
            s.play().catch(e => {});
            poolIndex = (poolIndex + 1) % 10;
        }

        // --- ASSETS ---
        const stickmanImg = new Image(); stickmanImg.src = 'stickman.png';
        const fartmanImg = new Image(); fartmanImg.src = 'fartman.png';

        const styles = ['classic', 'sketch', 'neon', 'blueprint'];
        let styleIdx = 0;
        
        let state = { 
            active: false, frame: 0, score: 0,
            nextStyleFrame: 0, // When to change style automatically
            hero: { x: 80, y: 300, v: 0, puff: 0, rot: 0, sX: 1, sY: 1, trail: [] },
            pipes: [], particles: []
        };

        function resize() {
            canvas.width = Math.min(window.innerWidth, 400);
            canvas.height = Math.min(window.innerHeight, 650);
        }
        window.addEventListener('resize', resize);
        resize();

        // --- STYLE LOGIC ---
        function setStyle(idx) {
            styleIdx = idx;
            const s = styles[styleIdx];
            styleToggle.className = `font-${s}`;
            
            if(s === 'neon') { 
                canvas.style.background = "#050510"; canvas.style.borderColor = "#0ff"; 
                styleToggle.style.background = "#050510"; styleToggle.style.borderColor = "#0ff"; styleToggle.style.color = "#0ff"; styleToggle.style.boxShadow = "0 0 10px #0ff";
            } else if (s === 'blueprint') { 
                canvas.style.background = "#004488"; canvas.style.borderColor = "#fff"; 
                styleToggle.style.background = "#004488"; styleToggle.style.borderColor = "#fff"; styleToggle.style.color = "#fff"; styleToggle.style.boxShadow = "4px 4px 0px #fff";
            } else if (s === 'sketch') { 
                canvas.style.background = "#f0f0f0"; canvas.style.borderColor = "#333"; 
                styleToggle.style.background = "#fff"; styleToggle.style.borderColor = "#333"; styleToggle.style.color = "#333"; styleToggle.style.boxShadow = "2px 2px 5px rgba(0,0,0,0.2)";
            } else { 
                canvas.style.background = "#fff"; canvas.style.borderColor = "#000"; 
                styleToggle.style.background = "#fff"; styleToggle.style.borderColor = "#000"; styleToggle.style.color = "#000"; styleToggle.style.boxShadow = "4px 4px 0px #000";
            }
            
            // Set next random interval (300 to 720 frames = ~5 to 12 seconds)
            state.nextStyleFrame = state.frame + (300 + Math.random() * 420);
        }

        styleToggle.addEventListener('click', () => {
            setStyle((styleIdx + 1) % styles.length);
        });

        function jump() {
            if (!state.active) return;
            state.hero.v = -6.5; state.hero.puff = 15;
            state.hero.sX = 1.3; state.hero.sY = 0.7;
            playJump();
            const pColor = styles[styleIdx] === 'neon' ? '#0ff' : (styles[styleIdx] === 'blueprint' ? '#fff' : '#666');
            for(let i=0; i<6; i++) state.particles.push({x: state.hero.x, y: state.hero.y + 20, vx: -2 - Math.random()*3, vy: (Math.random()-0.5)*4, life: 20, color: pColor, size: Math.random()*5});
        }

        startBtn.addEventListener('click', () => {
            ui.style.display = 'none';
            state.active = true;
            state.frame = 0;
            state.score = 0;
            state.pipes = [];
            state.hero.y = canvas.height/2; state.hero.v = 0; state.hero.trail = [];
            setStyle(0); // Start with Classic
            startSnd.play().catch(e => {});
        });

        window.addEventListener('keydown', e => { if(e.code === 'Space') jump(); });
        canvas.addEventListener('mousedown', e => { e.preventDefault(); jump(); });
        canvas.addEventListener('touchstart', e => { e.preventDefault(); jump(); });

        function update() {
            if (!state.active) return;
            state.frame++;

            // --- AUTO STYLE SWITCH CHECK ---
            if (state.frame >= state.nextStyleFrame) {
                // Pick a new random style index different from current
                let nextIdx;
                do { nextIdx = Math.floor(Math.random() * styles.length); } while (nextIdx === styleIdx);
                setStyle(nextIdx);
            }

            state.hero.v += 0.3;
            state.hero.y += state.hero.v;
            state.hero.rot = Math.max(-0.6, Math.min(0.6, state.hero.v * 0.1));
            state.hero.sX += (1 - state.hero.sX) * 0.2;
            state.hero.sY += (1 - state.hero.sY) * 0.2;

            if (state.hero.puff > 0) state.hero.puff--;
            state.hero.trail.push({x: state.hero.x, y: state.hero.y, rot: state.hero.rot});
            if(state.hero.trail.length > 8) state.hero.trail.shift();

            if (state.hero.v > 0 && state.hero.y > canvas.height - 110 && state.frame % 35 === 0) {
                warningSnd.currentTime = 0; warningSnd.play().catch(e => {});
            }

            if (state.hero.y > canvas.height || state.hero.y < -50) {
                state.active = false; ui.style.display = 'block'; gameOverSnd.play().catch(e => {});
            }

            if (state.frame % 85 === 0) state.pipes.push({ x: canvas.width, top: Math.random()*(canvas.height-320)+80, passed: false, warned: false });

            state.pipes.forEach(p => {
                p.x -= 4;
                if (!p.warned && state.hero.v > 0 && p.x < state.hero.x + 80 && p.x > state.hero.x - 20) {
                    if (state.hero.y > (p.top + 185 - 55)) { warningSnd.currentTime = 0; warningSnd.play().catch(e => {}); p.warned = true; }
                }
                if (state.hero.x + 15 > p.x && state.hero.x - 15 < p.x + 60) {
                    if (state.hero.y - 15 < p.top || state.hero.y + 15 > p.top + 185) { state.active = false; ui.style.display = 'block'; gameOverSnd.play().catch(e => {}); }
                }
                if (!p.passed && p.x + 60 < state.hero.x) { p.passed = true; state.score++; if (state.score % 10 === 0) milestoneSnd.play().catch(e => {}); }
            });
            state.pipes = state.pipes.filter(p => p.x > -100);
            state.particles.forEach((p,i) => { p.x += p.vx; p.y += p.vy; p.life--; if(p.life <= 0) state.particles.splice(i, 1); });
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const mode = styles[styleIdx];

            if(mode === 'blueprint') {
                ctx.strokeStyle = "rgba(255, 255, 255, 0.2)";
                for(let i=0; i<canvas.width; i+=40) { ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, canvas.height); ctx.stroke(); }
                for(let i=0; i<canvas.height; i+=40) { ctx.beginPath(); ctx.moveTo(0, i); ctx.lineTo(canvas.width, i); ctx.stroke(); }
            }

            state.pipes.forEach(p => {
                if(mode === 'classic') {
                    ctx.fillStyle = "#ffcc33"; ctx.strokeStyle = "#000"; ctx.lineWidth = 3;
                    ctx.fillRect(p.x, 0, 60, p.top); ctx.strokeRect(p.x, 0, 60, p.top);
                    ctx.fillRect(p.x, p.top+185, 60, canvas.height); ctx.strokeRect(p.x, p.top+185, 60, canvas.height);
                } else if(mode === 'sketch') {
                    ctx.strokeStyle = "#333"; ctx.lineWidth = 2;
                    ctx.strokeRect(p.x + Math.random()*2, -5, 60, p.top+5); ctx.strokeRect(p.x + Math.random()*2, p.top+185, 60, canvas.height);
                } else if(mode === 'neon') {
                    ctx.shadowBlur = 15; ctx.shadowColor = "#0ff"; ctx.strokeStyle = "#0ff";
                    ctx.strokeRect(p.x, -5, 60, p.top+5); ctx.strokeRect(p.x, p.top+185, 60, canvas.height);
                    ctx.shadowBlur = 0;
                } else if(mode === 'blueprint') {
                    ctx.strokeStyle = "#fff"; ctx.setLineDash([10, 5]);
                    ctx.strokeRect(p.x+5, 0, 50, p.top); ctx.strokeRect(p.x+5, p.top+185, 50, canvas.height);
                    ctx.setLineDash([]);
                }
            });

            ctx.save();
            const h = state.hero;
            if(mode === 'sketch') {
                ctx.filter = 'grayscale(1) contrast(1.2) opacity(0.7)';
                ctx.translate(Math.random()*2, Math.random()*2);
            } else if(mode === 'neon') {
                h.trail.forEach((pos, i) => {
                    ctx.save(); ctx.globalAlpha = i / 10; ctx.translate(pos.x, pos.y); ctx.rotate(pos.rot);
                    ctx.filter = 'invert(1) sepia(1) saturate(100) hue-rotate(180deg) brightness(2)';
                    ctx.drawImage(stickmanImg, -35, -35, 70, 70); ctx.restore();
                });
                ctx.filter = 'invert(1) sepia(1) saturate(100) hue-rotate(180deg) brightness(3)';
                ctx.shadowBlur = 20; ctx.shadowColor = "#0ff";
            } else if(mode === 'blueprint') { ctx.filter = 'invert(1) brightness(2)'; }

            ctx.translate(h.x, h.y); ctx.rotate(h.rot); ctx.scale(h.sX, h.sY);
            ctx.drawImage(h.puff > 0 ? fartmanImg : stickmanImg, -35, -35, 70, 70);
            ctx.restore();
            ctx.filter = 'none';

            state.particles.forEach(p => { ctx.globalAlpha = p.life/20; ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill(); });
            ctx.globalAlpha = 1;

            ctx.fillStyle = (mode === 'neon' || mode === 'blueprint') ? "#fff" : "#000";
            ctx.font = `bold 60px ${mode==='sketch'?"'Permanent Marker'":mode==='neon'?"'Orbitron'":mode==='blueprint'?"'Special Elite'":"sans-serif"}`;
            ctx.textAlign = "center"; ctx.fillText(state.score, canvas.width/2, 100);

            update();
            requestAnimationFrame(draw);
        }
        draw();
    </script>
</body>
</html>